/* tslint:disable */
/* eslint-disable */
/**
 * Mix It Up Developer API
 * # Introduction The Developer API allows our more advanced users to interact with Mix It Up using external or customized programs. To use this feature, ensure the Developer API is enabled on the Services page. All APIs are REST-like endpoints that you can perform calls receiving/using JSON text. All endpoints begin with the base address of http://localhost:8911/api/v2/ 
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface MixItUpChatMessage
 */
export interface MixItUpChatMessage {
    /**
     * The message to send to chat.
     * @type {string}
     * @memberof MixItUpChatMessage
     */
    'Message': string;
    /**
     * The streaming platform to send the message to.
     * @type {string}
     * @memberof MixItUpChatMessage
     */
    'Platform'?: string;
    /**
     * True will force the message to send as the streamer. False will try to send as the registered bot, if available.
     * @type {boolean}
     * @memberof MixItUpChatMessage
     */
    'SendAsStreamer'?: boolean;
}
/**
 * 
 * @export
 * @interface MixItUpCommand
 */
export interface MixItUpCommand {
    /**
     * The Mix It Up command ID.
     * @type {string}
     * @memberof MixItUpCommand
     */
    'ID': string;
    /**
     * The Mix It Up command name.
     * @type {string}
     * @memberof MixItUpCommand
     */
    'Name': string;
    /**
     * The Mix It Up command type.
     * @type {string}
     * @memberof MixItUpCommand
     */
    'Type'?: string;
    /**
     * True if enabled, false otherwise
     * @type {boolean}
     * @memberof MixItUpCommand
     */
    'IsEnabled': boolean;
    /**
     * Whether the command is unlocked or not.
     * @type {boolean}
     * @memberof MixItUpCommand
     */
    'Unlocked'?: boolean;
    /**
     * The name of the group the command belongs to, if any.
     * @type {string}
     * @memberof MixItUpCommand
     */
    'GroupName'?: string;
}
/**
 * 
 * @export
 * @interface MixItUpCommandParameters
 */
export interface MixItUpCommandParameters {
    /**
     * The streaming platform to send the message to.
     * @type {string}
     * @memberof MixItUpCommandParameters
     */
    'Platform'?: string;
    /**
     * The arguments for the command.
     * @type {string}
     * @memberof MixItUpCommandParameters
     */
    'Arguments'?: string;
}
/**
 * 
 * @export
 * @interface MixItUpCurrency
 */
export interface MixItUpCurrency {
    /**
     * The Mix It Up currency ID.
     * @type {string}
     * @memberof MixItUpCurrency
     */
    'ID': string;
    /**
     * The Mix It Up currency name.
     * @type {string}
     * @memberof MixItUpCurrency
     */
    'Name': string;
}
/**
 * 
 * @export
 * @interface MixItUpInventory
 */
export interface MixItUpInventory {
    /**
     * The Mix It Up inventory ID.
     * @type {string}
     * @memberof MixItUpInventory
     */
    'ID': string;
    /**
     * The Mix It Up inventory name.
     * @type {string}
     * @memberof MixItUpInventory
     */
    'Name': string;
    /**
     * 
     * @type {Array<MixItUpInventoryItem>}
     * @memberof MixItUpInventory
     */
    'Items'?: Array<MixItUpInventoryItem>;
}
/**
 * 
 * @export
 * @interface MixItUpInventoryItem
 */
export interface MixItUpInventoryItem {
    /**
     * The Mix It Up inventory item ID.
     * @type {string}
     * @memberof MixItUpInventoryItem
     */
    'ID': string;
    /**
     * The Mix It Up inventory item name.
     * @type {string}
     * @memberof MixItUpInventoryItem
     */
    'Name': string;
}
/**
 * 
 * @export
 * @interface MixItUpInventoryItemAmount
 */
export interface MixItUpInventoryItemAmount {
    /**
     * The Mix It Up inventory item ID.
     * @type {string}
     * @memberof MixItUpInventoryItemAmount
     */
    'ID': string;
    /**
     * The Mix It Up inventory item name.
     * @type {string}
     * @memberof MixItUpInventoryItemAmount
     */
    'Name': string;
    /**
     * The amount of this item the user has.
     * @type {number}
     * @memberof MixItUpInventoryItemAmount
     */
    'Amount'?: number;
}
/**
 * 
 * @export
 * @interface MixItUpPlatformUser
 */
export interface MixItUpPlatformUser {
    /**
     * The Platform name.
     * @type {string}
     * @memberof MixItUpPlatformUser
     */
    'Platform'?: string;
    /**
     * The Platform user ID.
     * @type {string}
     * @memberof MixItUpPlatformUser
     */
    'ID': string;
    /**
     * The Platform username.
     * @type {string}
     * @memberof MixItUpPlatformUser
     */
    'Username'?: string;
    /**
     * The Platform display name.
     * @type {string}
     * @memberof MixItUpPlatformUser
     */
    'DisplayName'?: string;
    /**
     * The Platform avatar URL.
     * @type {string}
     * @memberof MixItUpPlatformUser
     */
    'AvatarLink'?: string;
    /**
     * The Platform subscriber badge URL.
     * @type {string}
     * @memberof MixItUpPlatformUser
     */
    'SubscriberBadgeLink'?: string;
    /**
     * The Platform role badge URL.
     * @type {string}
     * @memberof MixItUpPlatformUser
     */
    'RoleBadgeLink'?: string;
    /**
     * The Platform specialty badge URL.
     * @type {string}
     * @memberof MixItUpPlatformUser
     */
    'SpecialtyBadgeLink'?: string;
    /**
     * The list of Platform roles.
     * @type {Array<string>}
     * @memberof MixItUpPlatformUser
     */
    'Roles'?: Array<string>;
    /**
     * The platform account date.
     * @type {string}
     * @memberof MixItUpPlatformUser
     */
    'AccountDate'?: string;
    /**
     * The platform follow date.
     * @type {string}
     * @memberof MixItUpPlatformUser
     */
    'FollowDate'?: string;
    /**
     * The platform subscriber date.
     * @type {string}
     * @memberof MixItUpPlatformUser
     */
    'SubscribeDate'?: string;
    /**
     * The platform subscriber tier.
     * @type {number}
     * @memberof MixItUpPlatformUser
     */
    'SubscriberTier'?: number;
}
/**
 * 
 * @export
 * @interface MixItUpUser
 */
export interface MixItUpUser {
    /**
     * The Mix It Up User ID.
     * @type {string}
     * @memberof MixItUpUser
     */
    'ID': string;
    /**
     * 
     * @type {{ [key: string]: MixItUpPlatformUser; }}
     * @memberof MixItUpUser
     */
    'PlatformData'?: { [key: string]: MixItUpPlatformUser; };
    /**
     * The last date time of activity.
     * @type {string}
     * @memberof MixItUpUser
     */
    'LastActivity'?: string;
    /**
     * The last date time of updates.
     * @type {string}
     * @memberof MixItUpUser
     */
    'LastUpdated'?: string;
    /**
     * The total number of online viewing minutes in your stream.
     * @type {number}
     * @memberof MixItUpUser
     */
    'OnlineViewingMinutes'?: number;
    /**
     * The user\'s custom title.
     * @type {string}
     * @memberof MixItUpUser
     */
    'CustomTitle'?: string;
    /**
     * Whether the user is a specialty excluded user.
     * @type {boolean}
     * @memberof MixItUpUser
     */
    'IsSpecialtyExcluded'?: boolean;
    /**
     * The notes for the user.
     * @type {string}
     * @memberof MixItUpUser
     */
    'Notes'?: string;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof MixItUpUser
     */
    'CurrencyAmounts'?: { [key: string]: number; };
    /**
     * 
     * @type {{ [key: string]: { [key: string]: number; }; }}
     * @memberof MixItUpUser
     */
    'InventoryAmounts'?: { [key: string]: { [key: string]: number; }; };
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof MixItUpUser
     */
    'StreamPassAmounts'?: { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * A description of the problem.
     * @type {string}
     * @memberof ModelError
     */
    'Message': string;
}
/**
 * 
 * @export
 * @interface UpdateCurrencyAmount
 */
export interface UpdateCurrencyAmount {
    /**
     * The amount to adjust the user\'s currency.  This amount may be positive or negative.
     * @type {number}
     * @memberof UpdateCurrencyAmount
     */
    'Amount': number;
}
/**
 * 
 * @export
 * @interface UpdateInventoryAmount
 */
export interface UpdateInventoryAmount {
    /**
     * The amount to adjust the user\'s inventory item.  This amount may be positive or negative.
     * @type {number}
     * @memberof UpdateInventoryAmount
     */
    'Amount': number;
}

/**
 * ChatApi - axios parameter creator
 * @export
 */
export const ChatApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Clears the chat for all connected platforms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearChat: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chat/clear`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sends a message to the chat
         * @param {MixItUpChatMessage} chatMessage The chat message to send
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendChatMessage: async (chatMessage: MixItUpChatMessage, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatMessage' is not null or undefined
            assertParamExists('sendChatMessage', 'chatMessage', chatMessage)
            const localVarPath = `/chat/message`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatMessage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatApi - functional programming interface
 * @export
 */
export const ChatApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Clears the chat for all connected platforms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clearChat(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clearChat(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.clearChat']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Sends a message to the chat
         * @param {MixItUpChatMessage} chatMessage The chat message to send
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendChatMessage(chatMessage: MixItUpChatMessage, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendChatMessage(chatMessage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.sendChatMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChatApi - factory interface
 * @export
 */
export const ChatApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatApiFp(configuration)
    return {
        /**
         * 
         * @summary Clears the chat for all connected platforms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearChat(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.clearChat(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sends a message to the chat
         * @param {MixItUpChatMessage} chatMessage The chat message to send
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendChatMessage(chatMessage: MixItUpChatMessage, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sendChatMessage(chatMessage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChatApi - object-oriented interface
 * @export
 * @class ChatApi
 * @extends {BaseAPI}
 */
export class ChatApi extends BaseAPI {
    /**
     * 
     * @summary Clears the chat for all connected platforms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public clearChat(options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).clearChat(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sends a message to the chat
     * @param {MixItUpChatMessage} chatMessage The chat message to send
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public sendChatMessage(chatMessage: MixItUpChatMessage, options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).sendChatMessage(chatMessage, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CommandsApi - axios parameter creator
 * @export
 */
export const CommandsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a list of all commands available.
         * @param {string} skip How many commands to skip
         * @param {string} pageSize The total number of commands to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCommands: async (skip: string, pageSize: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'skip' is not null or undefined
            assertParamExists('getAllCommands', 'skip', skip)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('getAllCommands', 'pageSize', pageSize)
            const localVarPath = `/commands`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the requested command.
         * @param {string} commandId The command ID to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommand: async (commandId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commandId' is not null or undefined
            assertParamExists('getCommand', 'commandId', commandId)
            const localVarPath = `/commands/{commandId}`
                .replace(`{${"commandId"}}`, encodeURIComponent(String(commandId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Used to run the requested command.
         * @param {string} commandId The command ID to query
         * @param {MixItUpCommandParameters} parameters The parameters to run the command
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runCommand: async (commandId: string, parameters: MixItUpCommandParameters, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commandId' is not null or undefined
            assertParamExists('runCommand', 'commandId', commandId)
            // verify required parameter 'parameters' is not null or undefined
            assertParamExists('runCommand', 'parameters', parameters)
            const localVarPath = `/commands/{commandId}`
                .replace(`{${"commandId"}}`, encodeURIComponent(String(commandId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(parameters, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the command\'s state\'.
         * @param {string} commandId The command ID to query
         * @param {number} state The state to update the command to (0 &#x3D; Disabled, 1 &#x3D; Enabled, 2 &#x3D; Toggle)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCommandState: async (commandId: string, state: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commandId' is not null or undefined
            assertParamExists('updateCommandState', 'commandId', commandId)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('updateCommandState', 'state', state)
            const localVarPath = `/commands/{commandId}/state/{state}`
                .replace(`{${"commandId"}}`, encodeURIComponent(String(commandId)))
                .replace(`{${"state"}}`, encodeURIComponent(String(state)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommandsApi - functional programming interface
 * @export
 */
export const CommandsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommandsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Gets a list of all commands available.
         * @param {string} skip How many commands to skip
         * @param {string} pageSize The total number of commands to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCommands(skip: string, pageSize: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MixItUpCommand>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCommands(skip, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommandsApi.getAllCommands']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets the requested command.
         * @param {string} commandId The command ID to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommand(commandId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MixItUpCommand>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommand(commandId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommandsApi.getCommand']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Used to run the requested command.
         * @param {string} commandId The command ID to query
         * @param {MixItUpCommandParameters} parameters The parameters to run the command
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runCommand(commandId: string, parameters: MixItUpCommandParameters, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runCommand(commandId, parameters, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommandsApi.runCommand']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates the command\'s state\'.
         * @param {string} commandId The command ID to query
         * @param {number} state The state to update the command to (0 &#x3D; Disabled, 1 &#x3D; Enabled, 2 &#x3D; Toggle)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCommandState(commandId: string, state: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MixItUpCommand>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCommandState(commandId, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommandsApi.updateCommandState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CommandsApi - factory interface
 * @export
 */
export const CommandsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommandsApiFp(configuration)
    return {
        /**
         * 
         * @summary Gets a list of all commands available.
         * @param {string} skip How many commands to skip
         * @param {string} pageSize The total number of commands to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCommands(skip: string, pageSize: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<MixItUpCommand>> {
            return localVarFp.getAllCommands(skip, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the requested command.
         * @param {string} commandId The command ID to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommand(commandId: string, options?: RawAxiosRequestConfig): AxiosPromise<MixItUpCommand> {
            return localVarFp.getCommand(commandId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Used to run the requested command.
         * @param {string} commandId The command ID to query
         * @param {MixItUpCommandParameters} parameters The parameters to run the command
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runCommand(commandId: string, parameters: MixItUpCommandParameters, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.runCommand(commandId, parameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the command\'s state\'.
         * @param {string} commandId The command ID to query
         * @param {number} state The state to update the command to (0 &#x3D; Disabled, 1 &#x3D; Enabled, 2 &#x3D; Toggle)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCommandState(commandId: string, state: number, options?: RawAxiosRequestConfig): AxiosPromise<MixItUpCommand> {
            return localVarFp.updateCommandState(commandId, state, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommandsApi - object-oriented interface
 * @export
 * @class CommandsApi
 * @extends {BaseAPI}
 */
export class CommandsApi extends BaseAPI {
    /**
     * 
     * @summary Gets a list of all commands available.
     * @param {string} skip How many commands to skip
     * @param {string} pageSize The total number of commands to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public getAllCommands(skip: string, pageSize: string, options?: RawAxiosRequestConfig) {
        return CommandsApiFp(this.configuration).getAllCommands(skip, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the requested command.
     * @param {string} commandId The command ID to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public getCommand(commandId: string, options?: RawAxiosRequestConfig) {
        return CommandsApiFp(this.configuration).getCommand(commandId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Used to run the requested command.
     * @param {string} commandId The command ID to query
     * @param {MixItUpCommandParameters} parameters The parameters to run the command
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public runCommand(commandId: string, parameters: MixItUpCommandParameters, options?: RawAxiosRequestConfig) {
        return CommandsApiFp(this.configuration).runCommand(commandId, parameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the command\'s state\'.
     * @param {string} commandId The command ID to query
     * @param {number} state The state to update the command to (0 &#x3D; Disabled, 1 &#x3D; Enabled, 2 &#x3D; Toggle)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public updateCommandState(commandId: string, state: number, options?: RawAxiosRequestConfig) {
        return CommandsApiFp(this.configuration).updateCommandState(commandId, state, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CurrencyApi - axios parameter creator
 * @export
 */
export const CurrencyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a list of all currencies available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCurrencies: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/currency`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the currency amount for a specific user
         * @param {string} currencyId The currency ID to query
         * @param {string} userId The Mix It Up user ID to query for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencyById: async (currencyId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currencyId' is not null or undefined
            assertParamExists('getCurrencyById', 'currencyId', currencyId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getCurrencyById', 'userId', userId)
            const localVarPath = `/currency/{currencyId}/{userId}`
                .replace(`{${"currencyId"}}`, encodeURIComponent(String(currencyId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the currency amount for a specific user
         * @param {string} currencyId The currency ID to query
         * @param {string} userId The Mix It Up user ID to query for
         * @param {UpdateCurrencyAmount} updateAmount The amount to update the currency by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCurrencyById: async (currencyId: string, userId: string, updateAmount: UpdateCurrencyAmount, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currencyId' is not null or undefined
            assertParamExists('patchCurrencyById', 'currencyId', currencyId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('patchCurrencyById', 'userId', userId)
            // verify required parameter 'updateAmount' is not null or undefined
            assertParamExists('patchCurrencyById', 'updateAmount', updateAmount)
            const localVarPath = `/currency/{currencyId}/{userId}`
                .replace(`{${"currencyId"}}`, encodeURIComponent(String(currencyId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAmount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the currency amount for a specific user
         * @param {string} currencyId The currency ID to query
         * @param {string} userId The Mix It Up user ID to query for
         * @param {UpdateCurrencyAmount} updateAmount The amount to set the currency to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCurrencyById: async (currencyId: string, userId: string, updateAmount: UpdateCurrencyAmount, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currencyId' is not null or undefined
            assertParamExists('putCurrencyById', 'currencyId', currencyId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('putCurrencyById', 'userId', userId)
            // verify required parameter 'updateAmount' is not null or undefined
            assertParamExists('putCurrencyById', 'updateAmount', updateAmount)
            const localVarPath = `/currency/{currencyId}/{userId}`
                .replace(`{${"currencyId"}}`, encodeURIComponent(String(currencyId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAmount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CurrencyApi - functional programming interface
 * @export
 */
export const CurrencyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CurrencyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Gets a list of all currencies available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCurrencies(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MixItUpCurrency>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCurrencies(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CurrencyApi.getAllCurrencies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets the currency amount for a specific user
         * @param {string} currencyId The currency ID to query
         * @param {string} userId The Mix It Up user ID to query for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrencyById(currencyId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrencyById(currencyId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CurrencyApi.getCurrencyById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates the currency amount for a specific user
         * @param {string} currencyId The currency ID to query
         * @param {string} userId The Mix It Up user ID to query for
         * @param {UpdateCurrencyAmount} updateAmount The amount to update the currency by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchCurrencyById(currencyId: string, userId: string, updateAmount: UpdateCurrencyAmount, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchCurrencyById(currencyId, userId, updateAmount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CurrencyApi.patchCurrencyById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set the currency amount for a specific user
         * @param {string} currencyId The currency ID to query
         * @param {string} userId The Mix It Up user ID to query for
         * @param {UpdateCurrencyAmount} updateAmount The amount to set the currency to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCurrencyById(currencyId: string, userId: string, updateAmount: UpdateCurrencyAmount, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putCurrencyById(currencyId, userId, updateAmount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CurrencyApi.putCurrencyById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CurrencyApi - factory interface
 * @export
 */
export const CurrencyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CurrencyApiFp(configuration)
    return {
        /**
         * 
         * @summary Gets a list of all currencies available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCurrencies(options?: RawAxiosRequestConfig): AxiosPromise<Array<MixItUpCurrency>> {
            return localVarFp.getAllCurrencies(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the currency amount for a specific user
         * @param {string} currencyId The currency ID to query
         * @param {string} userId The Mix It Up user ID to query for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencyById(currencyId: string, userId: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.getCurrencyById(currencyId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the currency amount for a specific user
         * @param {string} currencyId The currency ID to query
         * @param {string} userId The Mix It Up user ID to query for
         * @param {UpdateCurrencyAmount} updateAmount The amount to update the currency by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCurrencyById(currencyId: string, userId: string, updateAmount: UpdateCurrencyAmount, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.patchCurrencyById(currencyId, userId, updateAmount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set the currency amount for a specific user
         * @param {string} currencyId The currency ID to query
         * @param {string} userId The Mix It Up user ID to query for
         * @param {UpdateCurrencyAmount} updateAmount The amount to set the currency to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCurrencyById(currencyId: string, userId: string, updateAmount: UpdateCurrencyAmount, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.putCurrencyById(currencyId, userId, updateAmount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CurrencyApi - object-oriented interface
 * @export
 * @class CurrencyApi
 * @extends {BaseAPI}
 */
export class CurrencyApi extends BaseAPI {
    /**
     * 
     * @summary Gets a list of all currencies available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public getAllCurrencies(options?: RawAxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).getAllCurrencies(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the currency amount for a specific user
     * @param {string} currencyId The currency ID to query
     * @param {string} userId The Mix It Up user ID to query for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public getCurrencyById(currencyId: string, userId: string, options?: RawAxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).getCurrencyById(currencyId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the currency amount for a specific user
     * @param {string} currencyId The currency ID to query
     * @param {string} userId The Mix It Up user ID to query for
     * @param {UpdateCurrencyAmount} updateAmount The amount to update the currency by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public patchCurrencyById(currencyId: string, userId: string, updateAmount: UpdateCurrencyAmount, options?: RawAxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).patchCurrencyById(currencyId, userId, updateAmount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set the currency amount for a specific user
     * @param {string} currencyId The currency ID to query
     * @param {string} userId The Mix It Up user ID to query for
     * @param {UpdateCurrencyAmount} updateAmount The amount to set the currency to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public putCurrencyById(currencyId: string, userId: string, updateAmount: UpdateCurrencyAmount, options?: RawAxiosRequestConfig) {
        return CurrencyApiFp(this.configuration).putCurrencyById(currencyId, userId, updateAmount, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InventoryApi - axios parameter creator
 * @export
 */
export const InventoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a list of all inventories available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInventories: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/inventory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a specific inventory for a specific user
         * @param {string} inventoryId The inventory ID to query
         * @param {string} userId The Mix It Up user ID to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryById: async (inventoryId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inventoryId' is not null or undefined
            assertParamExists('getInventoryById', 'inventoryId', inventoryId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getInventoryById', 'userId', userId)
            const localVarPath = `/inventory/{inventoryId}/{userId}`
                .replace(`{${"inventoryId"}}`, encodeURIComponent(String(inventoryId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the inventory item amount for a specific user
         * @param {string} inventoryId The inventory ID to query
         * @param {string} itemId The inventory item ID to query
         * @param {string} userId The Mix It Up user ID to query for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryItemById: async (inventoryId: string, itemId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inventoryId' is not null or undefined
            assertParamExists('getInventoryItemById', 'inventoryId', inventoryId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getInventoryItemById', 'itemId', itemId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getInventoryItemById', 'userId', userId)
            const localVarPath = `/inventory/{inventoryId}/{itemId}/{userId}`
                .replace(`{${"inventoryId"}}`, encodeURIComponent(String(inventoryId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the inventory item amount for a specific user
         * @param {string} inventoryId The inventory ID to query
         * @param {string} itemId The inventory item ID to query
         * @param {string} userId The Mix It Up user ID to query for
         * @param {UpdateInventoryAmount} updateAmount The amount to update the inventory item by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchInventoryItemById: async (inventoryId: string, itemId: string, userId: string, updateAmount: UpdateInventoryAmount, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inventoryId' is not null or undefined
            assertParamExists('patchInventoryItemById', 'inventoryId', inventoryId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('patchInventoryItemById', 'itemId', itemId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('patchInventoryItemById', 'userId', userId)
            // verify required parameter 'updateAmount' is not null or undefined
            assertParamExists('patchInventoryItemById', 'updateAmount', updateAmount)
            const localVarPath = `/inventory/{inventoryId}/{itemId}/{userId}`
                .replace(`{${"inventoryId"}}`, encodeURIComponent(String(inventoryId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAmount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the inventory item amount for a specific user
         * @param {string} inventoryId The inventory ID to query
         * @param {string} itemId The inventory item ID to query
         * @param {string} userId The Mix It Up user ID to query for
         * @param {UpdateInventoryAmount} updateAmount The amount to set the inventory item to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putInventoryById: async (inventoryId: string, itemId: string, userId: string, updateAmount: UpdateInventoryAmount, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inventoryId' is not null or undefined
            assertParamExists('putInventoryById', 'inventoryId', inventoryId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('putInventoryById', 'itemId', itemId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('putInventoryById', 'userId', userId)
            // verify required parameter 'updateAmount' is not null or undefined
            assertParamExists('putInventoryById', 'updateAmount', updateAmount)
            const localVarPath = `/inventory/{inventoryId}/{itemId}/{userId}`
                .replace(`{${"inventoryId"}}`, encodeURIComponent(String(inventoryId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAmount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InventoryApi - functional programming interface
 * @export
 */
export const InventoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InventoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Gets a list of all inventories available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllInventories(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MixItUpInventory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllInventories(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InventoryApi.getAllInventories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets a specific inventory for a specific user
         * @param {string} inventoryId The inventory ID to query
         * @param {string} userId The Mix It Up user ID to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInventoryById(inventoryId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MixItUpInventoryItemAmount>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInventoryById(inventoryId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InventoryApi.getInventoryById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets the inventory item amount for a specific user
         * @param {string} inventoryId The inventory ID to query
         * @param {string} itemId The inventory item ID to query
         * @param {string} userId The Mix It Up user ID to query for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInventoryItemById(inventoryId: string, itemId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInventoryItemById(inventoryId, itemId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InventoryApi.getInventoryItemById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates the inventory item amount for a specific user
         * @param {string} inventoryId The inventory ID to query
         * @param {string} itemId The inventory item ID to query
         * @param {string} userId The Mix It Up user ID to query for
         * @param {UpdateInventoryAmount} updateAmount The amount to update the inventory item by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchInventoryItemById(inventoryId: string, itemId: string, userId: string, updateAmount: UpdateInventoryAmount, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchInventoryItemById(inventoryId, itemId, userId, updateAmount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InventoryApi.patchInventoryItemById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set the inventory item amount for a specific user
         * @param {string} inventoryId The inventory ID to query
         * @param {string} itemId The inventory item ID to query
         * @param {string} userId The Mix It Up user ID to query for
         * @param {UpdateInventoryAmount} updateAmount The amount to set the inventory item to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putInventoryById(inventoryId: string, itemId: string, userId: string, updateAmount: UpdateInventoryAmount, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putInventoryById(inventoryId, itemId, userId, updateAmount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InventoryApi.putInventoryById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InventoryApi - factory interface
 * @export
 */
export const InventoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InventoryApiFp(configuration)
    return {
        /**
         * 
         * @summary Gets a list of all inventories available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInventories(options?: RawAxiosRequestConfig): AxiosPromise<Array<MixItUpInventory>> {
            return localVarFp.getAllInventories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a specific inventory for a specific user
         * @param {string} inventoryId The inventory ID to query
         * @param {string} userId The Mix It Up user ID to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryById(inventoryId: string, userId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<MixItUpInventoryItemAmount>> {
            return localVarFp.getInventoryById(inventoryId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the inventory item amount for a specific user
         * @param {string} inventoryId The inventory ID to query
         * @param {string} itemId The inventory item ID to query
         * @param {string} userId The Mix It Up user ID to query for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryItemById(inventoryId: string, itemId: string, userId: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.getInventoryItemById(inventoryId, itemId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the inventory item amount for a specific user
         * @param {string} inventoryId The inventory ID to query
         * @param {string} itemId The inventory item ID to query
         * @param {string} userId The Mix It Up user ID to query for
         * @param {UpdateInventoryAmount} updateAmount The amount to update the inventory item by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchInventoryItemById(inventoryId: string, itemId: string, userId: string, updateAmount: UpdateInventoryAmount, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.patchInventoryItemById(inventoryId, itemId, userId, updateAmount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set the inventory item amount for a specific user
         * @param {string} inventoryId The inventory ID to query
         * @param {string} itemId The inventory item ID to query
         * @param {string} userId The Mix It Up user ID to query for
         * @param {UpdateInventoryAmount} updateAmount The amount to set the inventory item to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putInventoryById(inventoryId: string, itemId: string, userId: string, updateAmount: UpdateInventoryAmount, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.putInventoryById(inventoryId, itemId, userId, updateAmount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InventoryApi - object-oriented interface
 * @export
 * @class InventoryApi
 * @extends {BaseAPI}
 */
export class InventoryApi extends BaseAPI {
    /**
     * 
     * @summary Gets a list of all inventories available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public getAllInventories(options?: RawAxiosRequestConfig) {
        return InventoryApiFp(this.configuration).getAllInventories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a specific inventory for a specific user
     * @param {string} inventoryId The inventory ID to query
     * @param {string} userId The Mix It Up user ID to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public getInventoryById(inventoryId: string, userId: string, options?: RawAxiosRequestConfig) {
        return InventoryApiFp(this.configuration).getInventoryById(inventoryId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the inventory item amount for a specific user
     * @param {string} inventoryId The inventory ID to query
     * @param {string} itemId The inventory item ID to query
     * @param {string} userId The Mix It Up user ID to query for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public getInventoryItemById(inventoryId: string, itemId: string, userId: string, options?: RawAxiosRequestConfig) {
        return InventoryApiFp(this.configuration).getInventoryItemById(inventoryId, itemId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the inventory item amount for a specific user
     * @param {string} inventoryId The inventory ID to query
     * @param {string} itemId The inventory item ID to query
     * @param {string} userId The Mix It Up user ID to query for
     * @param {UpdateInventoryAmount} updateAmount The amount to update the inventory item by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public patchInventoryItemById(inventoryId: string, itemId: string, userId: string, updateAmount: UpdateInventoryAmount, options?: RawAxiosRequestConfig) {
        return InventoryApiFp(this.configuration).patchInventoryItemById(inventoryId, itemId, userId, updateAmount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set the inventory item amount for a specific user
     * @param {string} inventoryId The inventory ID to query
     * @param {string} itemId The inventory item ID to query
     * @param {string} userId The Mix It Up user ID to query for
     * @param {UpdateInventoryAmount} updateAmount The amount to set the inventory item to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public putInventoryById(inventoryId: string, itemId: string, userId: string, updateAmount: UpdateInventoryAmount, options?: RawAxiosRequestConfig) {
        return InventoryApiFp(this.configuration).putInventoryById(inventoryId, itemId, userId, updateAmount, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the Mix It Up version number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusVersion: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatusApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Gets the Mix It Up version number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusVersion(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusVersion(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusApi.statusVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatusApiFp(configuration)
    return {
        /**
         * 
         * @summary Gets the Mix It Up version number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusVersion(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.statusVersion(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
    /**
     * 
     * @summary Gets the Mix It Up version number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public statusVersion(options?: RawAxiosRequestConfig) {
        return StatusApiFp(this.configuration).statusVersion(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get user data by platform username or ID
         * @param {string} platform The name of the streaming platform (EX: Twitch, YouTube, etc.)
         * @param {string} usernameOrID The platform username or ID that needs to be fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatformUserByUsernameOrID: async (platform: string, usernameOrID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getPlatformUserByUsernameOrID', 'platform', platform)
            // verify required parameter 'usernameOrID' is not null or undefined
            assertParamExists('getPlatformUserByUsernameOrID', 'usernameOrID', usernameOrID)
            const localVarPath = `/users/{platform}/{usernameOrID}`
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"usernameOrID"}}`, encodeURIComponent(String(usernameOrID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user data by Mix It Up user ID
         * @param {string} userId The Mix It Up user ID that needs to be fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userId: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('userId', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary This API can be used to lookup multiple active users at once.
         * @param {string} skip How many users to skip
         * @param {string} pageSize The total number of users to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersActiveGet: async (skip: string, pageSize: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'skip' is not null or undefined
            assertParamExists('usersActiveGet', 'skip', skip)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('usersActiveGet', 'pageSize', pageSize)
            const localVarPath = `/users/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary This API can be used to lookup multiple users at once.
         * @param {string} skip How many users to skip
         * @param {string} pageSize The total number of users to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet: async (skip: string, pageSize: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'skip' is not null or undefined
            assertParamExists('usersGet', 'skip', skip)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('usersGet', 'pageSize', pageSize)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get user data by platform username or ID
         * @param {string} platform The name of the streaming platform (EX: Twitch, YouTube, etc.)
         * @param {string} usernameOrID The platform username or ID that needs to be fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlatformUserByUsernameOrID(platform: string, usernameOrID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MixItUpUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlatformUserByUsernameOrID(platform, usernameOrID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getPlatformUserByUsernameOrID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user data by Mix It Up user ID
         * @param {string} userId The Mix It Up user ID that needs to be fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userId(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MixItUpUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userId(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary This API can be used to lookup multiple active users at once.
         * @param {string} skip How many users to skip
         * @param {string} pageSize The total number of users to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersActiveGet(skip: string, pageSize: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MixItUpUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersActiveGet(skip, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersActiveGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary This API can be used to lookup multiple users at once.
         * @param {string} skip How many users to skip
         * @param {string} pageSize The total number of users to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGet(skip: string, pageSize: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MixItUpUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGet(skip, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.usersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Get user data by platform username or ID
         * @param {string} platform The name of the streaming platform (EX: Twitch, YouTube, etc.)
         * @param {string} usernameOrID The platform username or ID that needs to be fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatformUserByUsernameOrID(platform: string, usernameOrID: string, options?: RawAxiosRequestConfig): AxiosPromise<MixItUpUser> {
            return localVarFp.getPlatformUserByUsernameOrID(platform, usernameOrID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user data by Mix It Up user ID
         * @param {string} userId The Mix It Up user ID that needs to be fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userId(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<MixItUpUser> {
            return localVarFp.userId(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary This API can be used to lookup multiple active users at once.
         * @param {string} skip How many users to skip
         * @param {string} pageSize The total number of users to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersActiveGet(skip: string, pageSize: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<MixItUpUser>> {
            return localVarFp.usersActiveGet(skip, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary This API can be used to lookup multiple users at once.
         * @param {string} skip How many users to skip
         * @param {string} pageSize The total number of users to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(skip: string, pageSize: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<MixItUpUser>> {
            return localVarFp.usersGet(skip, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Get user data by platform username or ID
     * @param {string} platform The name of the streaming platform (EX: Twitch, YouTube, etc.)
     * @param {string} usernameOrID The platform username or ID that needs to be fetched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getPlatformUserByUsernameOrID(platform: string, usernameOrID: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getPlatformUserByUsernameOrID(platform, usernameOrID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user data by Mix It Up user ID
     * @param {string} userId The Mix It Up user ID that needs to be fetched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userId(userId: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userId(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary This API can be used to lookup multiple active users at once.
     * @param {string} skip How many users to skip
     * @param {string} pageSize The total number of users to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersActiveGet(skip: string, pageSize: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersActiveGet(skip, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary This API can be used to lookup multiple users at once.
     * @param {string} skip How many users to skip
     * @param {string} pageSize The total number of users to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersGet(skip: string, pageSize: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).usersGet(skip, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}



